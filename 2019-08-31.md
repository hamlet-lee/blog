# ANTLR4 Grammer
* 在线文档：https://github.com/antlr/antlr4/blob/master/doc/index.md

* 语法概述： https://github.com/antlr/antlr4/blob/master/doc/grammars.md

  >> 'Parser rule' names must start with a lowercase letter and 'lexer rules' must start with a capital letter.

* vscode 中可以使用插件 “ANTLR4 grammar syntax support”

* ANTLR4 语法片段解读
  ```g4
  statement
      : query                                                            #statementDefault
      | USE schema=identifier                                            #use
      | USE catalog=identifier '.' schema=identifier   
  ```
  1. `statement :` -> 这是 parser rule
  1. `shcema=identifier` -> 出现的rule `identifier` 变成 `schema` 成员
  1. `query` -> 首选 rule `query`

  ```g4
  singleStatement
    : statement EOF
    ;
  ```
  单 statement 定义， 这里 `EOF` 是什么呢？参考：https://stackoverflow.com/questions/17844248/when-is-eof-needed-in-antlr-4
  
  >> You should include an explicit EOF at the end of your entry rule any time you are trying to parse an entire input file. If you do not include the EOF, it means you are not trying to parse the entire input, and it's acceptable to parse only a portion of the input if it means avoiding a syntax error.

# Presto 源码分析 - Parse
以下是CLI发送 `select 1;` 服务端解析sql的调用栈
```text
"query-scheduler-856@41305" prio=5 tid=0xbc27 nid=NA runnable
  java.lang.Thread.State: RUNNABLE
	  at com.facebook.presto.sql.parser.SqlParser.createStatement(SqlParser.java:98)
	  at com.facebook.presto.execution.QueryPreparer.prepareQuery(QueryPreparer.java:56)
	  at com.facebook.presto.execution.SqlQueryManager.createQueryInternal(SqlQueryManager.java:343)
	  at com.facebook.presto.execution.SqlQueryManager.lambda$createQuery$4(SqlQueryManager.java:305)
	  at com.facebook.presto.execution.SqlQueryManager$$Lambda$1193.1572680147.run(Unknown Source:-1)
	  at com.facebook.presto.$gen.Presto_0_222_27c7628____20190805_074551_1.run(Unknown Source:-1)
	  at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
	  at java.util.concurrent.FutureTask.run(FutureTask.java:266)
	  at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	  at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	  at java.lang.Thread.run(Thread.java:748)
```

SqlQueryManager 是总管性质的
```java
// prepare query
            preparedQuery = queryPreparer.prepareQuery(session, query, warningCollector);

            // select resource group
            queryType = getQueryType(preparedQuery.getStatement().getClass());
            selectionContext = resourceGroupManager.selectGroup(new SelectionCriteria(
                    sessionContext.getIdentity().getPrincipal().isPresent(),
                    sessionContext.getIdentity().getUser(),
                    Optional.ofNullable(sessionContext.getSource()),
                    sessionContext.getClientTags(),
                    sessionContext.getResourceEstimates(),
                    queryType.map(Enum::name)));

            // apply system defaults for query
            session = sessionPropertyDefaults.newSessionWithDefaultProperties(session, queryType.map(Enum::name), selectionContext.getResourceGroupId());

            // mark existing transaction as active
            transactionManager.activateTransaction(session, isTransactionControlStatement(preparedQuery.getStatement()), accessControl);

            // create query execution
            QueryExecutionFactory<?> queryExecutionFactory = executionFactories.get(preparedQuery.getStatement().getClass());
            if (queryExecutionFactory == null) {
                throw new PrestoException(NOT_SUPPORTED, "Unsupported statement type: " + preparedQuery.getStatement().getClass().getSimpleName());
            }
            queryExecution = queryExecutionFactory.createQueryExecution(
                    query,
                    session,
                    preparedQuery,
                    selectionContext.getResourceGroupId(),
                    warningCollector,
                    queryType);
		    
		    ...
		    
		    resourceGroupManager.submit(preparedQuery.getStatement(), queryExecution, selectionContext, queryExecutor);
```

QueryType 则是语句类型
```java
public enum QueryType
{
    DATA_DEFINITION,
    DELETE,
    DESCRIBE,
    EXPLAIN,
    ANALYZE,
    INSERT,
    SELECT
}
```

sessionContext 有很多客户端环境属性

resourceGroupManager.submit() 是提交执行

InternalResourceGroup 会接受queryExecution，并执行
```java
 public void run(ManagedQueryExecution query)
    {
        synchronized (root) {
            if (!subGroups.isEmpty()) {
                throw new PrestoException(INVALID_RESOURCE_GROUP, format("Cannot add queries to %s. It is not a leaf group.", id));
            }
            // Check all ancestors for capacity
            InternalResourceGroup group = this;
            boolean canQueue = true;
            boolean canRun = true;
            while (true) {
                canQueue &= group.canQueueMore();
                canRun &= group.canRunMore();
                if (!group.parent.isPresent()) {
                    break;
                }
                group = group.parent.get();
            }
            if (!canQueue && !canRun) {
                query.fail(new QueryQueueFullException(id));
                return;
            }
            if (canRun) {
	    	// 开跑
                startInBackground(query);
            }
            else {
	        // 当前队列处于不能跑状态，入队
                enqueueQuery(query);
            }
            query.addStateChangeListener(state -> {
                if (state.isDone()) {
                    queryFinished(query);
                }
            });
        }
    }
```
