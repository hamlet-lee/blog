# Logstash 运行多个instance
* 参考：https://discuss.elastic.co/t/run-multiple-instance-of-logstash/92456/4

需要指定不同的path.data，例如

```shell
mkdir -p data/xxx
logstash -f xxx.conf --path.data=data/xxx
```

# Logstash 解析access log

* 参考1：config examples : https://www.elastic.co/guide/en/logstash/current/config-examples.html

* 参考2：grok的pattern定义：https://github.com/logstash-plugins/logstash-patterns-core/blob/4ba9bf573583ad510aaf4bd0b3418bdbe3402585/patterns/httpd

* 参考3：uri 解析： https://discuss.elastic.co/t/grok-uri-extract/54836/2

## 解析默认格式
```ruby
filter {
  grok {
    match => { "message" => "%{HTTPD_COMBINEDLOG}" }
  }
}
```

## Logstash 解析URL
如下可以实现，解析parameters

```
kv {
                source => "uri_query"
                field_split => "&"
                prefix => "query_"
        }
```

结果示例

```
{
       "uri_query" => "application=&inf.name=eth0&test1=blah&test2=blahblahblah",
       "query_inf.name" => "eth0",
       "query_test1" => "blah",
       "query_test2" => "blahblahblah"
}
```

如下可以实现，解析的parameters放在一个嵌套结构中
```
filter {
  grok {
    match => [ "url", "%{URIPROTO:uri_proto}://(?:%{USER:user}(?::[^@]*)?@)?(?:%{URIHOST:uri_domain})?(?:%{URIPATHPARAM:uri_param})?" ]
  }
  grok {
    match => [ "uri_param", "%{GREEDYDATA:uri_path}\?%{GREEDYDATA:uri_query}" ]
  }

  kv {
    source => "uri_query"
    field_split => "&"
    target => "query"
  }
}
```

```
 "url" => "http://cdn1cdedge0001.coxlab.net/_astats?application=&inf.name=eth0",
 "uri_proto" => "http",
 "uri_domain" => "cdn1cdedge0001.coxlab.net",
 "uri_param" => "/_astats?application=&inf.name=eth0",
 "uri_path" => "/_astats",
 "uri_query" => "application=&inf.name=eth0",
 "query" => {
    "inf.name" => "eth0"
 }
```

如下可以实现第一个不匹配时，匹配第二个
```
  grok {
      break_on_match => true
      match => [ "uri_param", "%{GREEDYDATA:uri_path}\?%{GREEDYDATA:uri_query}" ,
                 "uri_param","%{GREEDYDATA:uri_path}"
               ]
  }
```

# Logstash 中迭代所有fields的方法
参考： https://discuss.elastic.co/t/how-to-use-the-ruby-filter-to-loop-through-k-v-pairs-after-use-the-kv-filter/147665/4
```
filter {
  if [type] == "syslog" {
    kv {
      source => "message"
      field_split => "[,\s]"
      value_split => "="
    }
  }

  ruby {
    code => "
      hash = event.to_hash
      hash.each { |key,value|
        if value.include? '\"' 
          event.set(key, value.gsub!('\"', ''))
        end
      }
   "
}
```

# Ruby的gsub 和 gsub!
参考：https://blog.csdn.net/sqlxx/article/details/8164554
```
ruby中带“!"和不带"!"的方法的最大的区别就是带”!"的会改变调用对象本身了。比方说str.gsub(/a/, 'b')，不会改变str本身，只会返回一个新的str。而str.gsub!(/a/, 'b')就会把str本身给改了。



但是gsub和gsub!还有另外一个不同点就是，gsub不管怎么样都会返回一个新的字符串，而gsub!只有在有字符被替换的情况下才会返回一个新的字符串，假如说没有任何字符被替换，gsub!只会返回nil.
```

# Logstash 中批量做urldecode
从代码 https://github.com/logstash-plugins/logstash-filter-urldecode/blob/master/lib/logstash/filters/urldecode.rb 来看，可以把需要decode的放入一个HASH，然后再处理即可
```ruby
# Attempt to handle string, array, and hash values for fields.
  # For all other datatypes, just return, URI.unescape doesn't support them.
  def urldecode(value)
    case value
    when String
      escaped = unescape(value)
      return @converter.convert(escaped)
    when Array
      ret_values = []
      value.each { |v| ret_values << urldecode(v) }
      return ret_values
    when Hash
      ret_values = {}
      value.each { |k,v| ret_values[k] = urldecode(v) }
      return ret_values
    else
      return value
    end
  end
```
