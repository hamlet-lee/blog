# 调研：Yanagishima 的 SQL 语句如何保存
ConnectionProvider.java中看到，使用了sqlite做存储
```java
public class ConnectionProvider implements Provider<Connection> {

	private Connection connection;

	@Override
	public Connection get() {
		try {
			if (connection == null) {
				connection = DriverManager.getConnection("jdbc:sqlite:data/yanagishima.db");
			}

			return connection;
		} catch (SQLException e) {
			throw new RuntimeException(e);
		}
	}
}
```

TinyORMProvider.java 则看到，使用了TinyORM做O/R mapping
```java
public class TinyORMProvider implements Provider<TinyORM> {

	@Inject
	private Connection connection;

	@Override
	public TinyORM get() {
		TinyORM tinyORM =  new TinyORM(connection);
		tinyORM.setQueryTimeout(10);
		return tinyORM;
	}
}
```
`假如TinyORM支持MySQL，可能就比较容易共享这个SQL存储了。`
HistoryServlet.java 中，用到了这个TinyORM，读取Query历史。
```java
                if(engine == null) {
                    queryOptional = db.single(Query.class).where("query_id=? and datasource=?", queryidOptional.get(), datasource).execute();
                } else {
                    queryOptional = db.single(Query.class).where("query_id=? and datasource=? and engine=?", queryidOptional.get(), datasource, engine).execute();
                }

```

Query.java 则是历史的对象模型
```java
@Table("query")
@Data
@EqualsAndHashCode(callSuper = false)
public class Query extends Row<Query>{

    @PrimaryKey
    @Column("datasource")
    private String datasource;

    @PrimaryKey
    @Column("engine")
    private String engine;

    @PrimaryKey
    @Column("query_id")
    private String queryId;

    @Column("fetch_result_time_string")
    private String fetchResultTimeString;

    @Column("query_string")
    private String queryString;

    @Column("user")
    private String user;

    @Column("status")
    private String status;

    @Column("elapsed_time_millis")
    private Integer elapsedTimeMillis;

    @Column("result_file_size")
    private Integer resultFileSize;

    @Column("linenumber")
    private Integer linenumber;
}
```



# 调研：可更新的分布式列存储
* ClickHouse: https://www.altinity.com/blog/2018/10/16/updates-in-clickhouse 似乎提供update功能
* HBase：不知道全量读写效率如何
* Hive: acid table，不知道吞吐能力如何
* doris: 暂未调研
* 可以测试下orc格式读写一次的性能

# Shell 脚本对日期字符串做指定的运算
```shell
date +%Y%m%d -d "2019-01-01 +1 days"
```
输出
```shell
20190102
```

# Yarn Capacity Scheduler 的 配置
如果配置为
```xml
  <property>
    <name>yarn.scheduler.capacity.root.xxx_group.yyy.capacity</name>
    <value>9</value>
    <description>Default queue target capacity.</description>
  </property>

  <property>
    <name>yarn.scheduler.capacity.root.xxx_group.yyy.maximum-capacity</name>
    <value>6</value>
    <description>Default queue target capacity.</description>
  </property>
```
则运行
```shell
bin/yarn rmadmin -refreshQueues
```
会报错  
```text
Illegal queue capacity setting, (capacity=0.09) > (maximum-capacity=0.06). When label=[]
```
可见，maximum-capacity是相对于父队列的？

# Shell 的逻辑运算和字符串比较、数值比较
参见： https://www.tutorialspoint.com/unix/unix-basic-operators.htm
