# IP地址库合并算法设计
## 背景
为了提高ip地址解析的覆盖率，我们可能希望综合多个ip地址库的结果。如果逐个在线查询，会影响性能，并浪费存储。因此可以考虑将多个ip地址库按照预定的逻辑进行合并。  

## ip地址库的格式
ip地址库的格式通常类似如下：  
  ```text
  startIp1,endIp1,country1,province1,city1,operator1
  startIp2,endIp2,country2,province2,city2,operator2
  ...
  ```  
  其中 [startIp,endIp] 是一个地址闭区间，country、province、city、operator 是这个地址区间内ip的一些“属性”。  
  通常，这个文件中各行的 [startIp,endIp] 闭区间是不相交的，并且是已经按照 startIp 做升序排序的。
  country、province、city、operator 这些属性有可能会缺失，例如：  
```text
country=中国 province=未知 city=未知 operator=中国移动
```

## 合并的示例

不同的ip地址库之间，可能有能够互相补充的“属性”。例如（对于某个ip）:
```text
ip地址库1：  country=中国 province=未知 city=未知 operator=中国移动
ip地址库2：  country=中国 province=广东 city=广州 operator=未知
```
这时，如果合并两个地址库的结果，就可以获得更大的覆盖率。

## 合并算法
总体设计：分三步完成，  
* 第一步，拆分  
将ip地址段按照各个库的ip地址段覆盖情况拆分；拆分出来的每一段地址，关联到各个库中“属性集合”
* 第二步，属性合并  
对拆分出来的每个地址段对应的一个或多个“属性集”进行合并，生成单一的“属性集”
* 第三步，地址段合并  
为了删减冗余信息，对“中间结果”进行“地址段合并”：即如果存在连续的多个地址段对应到相同的“属性集合”，则进行合并

![img](https://raw.githubusercontent.com/hamlet-lee/blog/master/2019-07-23/ip_merge_algo.jpg)  

具体实现：
* 第一步，拆分
将ip库抽象为 IpSecAttrStream
```java
class IpSecAttrStream {
  Map<String,String> curAttr;
  long getValue() { return curStartIp; }
  long getCurStartIp() { ... } 
  long getCurEndIp() { ... }
}
```
把各个IpSecAttrStream放入小顶堆(Java中可以用PriorityQueue)

```java
// 初始化好各个库的Stream，放入streamList
List<IpSecAttrStream> streamList = ...

// 放入小顶堆
PriorityQueue q = ...
q.addAll(streamList)

// 取出并判断
while (!q.isEmpty()) {
  List<IpSecAttrStream> curIpSec = new ArrayList();
  IpSecAttrStream first = q.poll();
  curIpSec.add(first);
  
  while(!q.isEmpty()) {
    IpSecAttrStream next = q.peek();
    if( next != null && next.getCurStartIp() == first.getCurStartIp() ) {
      // startIp相同时，继续取出
      next = q.poll()
      curIpSec.add(next);
      next = q.peek();
    }
  }
}
```


